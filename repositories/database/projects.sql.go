// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: projects.sql

package database

import (
	"context"
	"database/sql"
)

const createProject = `-- name: CreateProject :one

INSERT INTO projects(title, description, type_id, duration_in_mins, release_year, director, producer)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type CreateProjectParams struct {
	Title          string
	Description    string
	TypeID         int64
	DurationInMins int64
	ReleaseYear    int64
	Director       string
	Producer       string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Title,
		arg.Description,
		arg.TypeID,
		arg.DurationInMins,
		arg.ReleaseYear,
		arg.Director,
		arg.Producer,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteProject = `-- name: DeleteProject :exec

DELETE FROM projects WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const getProjectById = `-- name: GetProjectById :one

SELECT id, created_at, updated_at, title, description, type_id, duration_in_mins, release_year, director, producer, cover FROM projects WHERE id = ?
`

func (q *Queries) GetProjectById(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectById, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.TypeID,
		&i.DurationInMins,
		&i.ReleaseYear,
		&i.Director,
		&i.Producer,
		&i.Cover,
	)
	return i, err
}

const getProjects = `-- name: GetProjects :many
SELECT id, created_at, updated_at, title, description, type_id, duration_in_mins, release_year, director, producer, cover FROM projects
`

func (q *Queries) GetProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.TypeID,
			&i.DurationInMins,
			&i.ReleaseYear,
			&i.Director,
			&i.Producer,
			&i.Cover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchlistProjects = `-- name: GetWatchlistProjects :many

SELECT p.id, p.created_at, p.updated_at, p.title, p.description, p.type_id, p.duration_in_mins, p.release_year, p.director, p.producer, p.cover
FROM projects AS p
JOIN watchlist AS w
ON p.id = w.project_id
WHERE w.user_id = ?
ORDER BY added_at
`

func (q *Queries) GetWatchlistProjects(ctx context.Context, userID int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getWatchlistProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.TypeID,
			&i.DurationInMins,
			&i.ReleaseYear,
			&i.Director,
			&i.Producer,
			&i.Cover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCover = `-- name: SetCover :exec

UPDATE projects
SET updated_at = CURRENT_TIMESTAMP,
    cover = ?
WHERE id = ?
`

type SetCoverParams struct {
	Cover sql.NullString
	ID    int64
}

func (q *Queries) SetCover(ctx context.Context, arg SetCoverParams) error {
	_, err := q.db.ExecContext(ctx, setCover, arg.Cover, arg.ID)
	return err
}

const updateProjects = `-- name: UpdateProjects :one

UPDATE projects 
SET updated_at = CURRENT_TIMESTAMP,
    title = ?, 
    description = ?, 
    type_id = ?,
    duration_in_mins = ?,
    release_year = ?, 
    director = ?,
    producer = ?
WHERE id = ?
RETURNING id, created_at, updated_at, title, description, type_id, duration_in_mins, release_year, director, producer, cover
`

type UpdateProjectsParams struct {
	Title          string
	Description    string
	TypeID         int64
	DurationInMins int64
	ReleaseYear    int64
	Director       string
	Producer       string
	ID             int64
}

func (q *Queries) UpdateProjects(ctx context.Context, arg UpdateProjectsParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjects,
		arg.Title,
		arg.Description,
		arg.TypeID,
		arg.DurationInMins,
		arg.ReleaseYear,
		arg.Director,
		arg.Producer,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.TypeID,
		&i.DurationInMins,
		&i.ReleaseYear,
		&i.Director,
		&i.Producer,
		&i.Cover,
	)
	return i, err
}
